{"version":3,"file":"register-explorer.js","sources":["../src/packets.ts","../src/fields.ts","../src/crc.ts","../src/request_encoder.ts","../src/response_decoder.ts","../src/client.ts","../src/request_decoder.ts","../src/response_encoder.ts","../src/server-model.ts"],"sourcesContent":["export interface ReadRequest {\n  command: \"Read\";\n  addr: number;\n  crc: number;\n  bytes?: Uint8Array;\n}\n\nexport interface WriteRequest {\n  command: \"Write\";\n  addr: number;\n  data: number;\n  crc: number;\n  bytes?: Uint8Array;\n}\n\nexport interface ReadResponse {\n  command: \"Read\";\n  data: number;\n  crc: number;\n  bytes?: Uint8Array;\n}\n\nexport interface WriteResponse {\n  command: \"Write\";\n  crc: number;\n  bytes?: Uint8Array;\n}\n\nexport type Request = ReadRequest | WriteRequest;\nexport type Response = ReadResponse | WriteResponse;\n\nexport function requestToString(request: Request): string {\n  const bytes = packetBytesToString(request);\n  const addr = request.addr.toString(16).padStart(8, \"0\");\n  switch (request.command) {\n    case \"Read\": {\n      const obj = { command: request.command, addr: addr, bytes: bytes };\n      return JSON.stringify(obj).replaceAll(\",\", \", \");\n    }\n    case \"Write\": {\n      const data = request.data.toString(16).padStart(8, \"0\");\n      const obj = {\n        command: request.command,\n        addr: addr,\n        data: data,\n        bytes: bytes,\n      };\n      return JSON.stringify(obj).replaceAll(\",\", \", \");\n    }\n  }\n}\n\nexport function responseToString(response: Response): string {\n  const bytes = packetBytesToString(response);\n  switch (response.command) {\n    case \"Read\": {\n      const data = response.data.toString(16).padStart(8, \"0\");\n      const obj = { command: response.command, data: data, bytes: bytes };\n      return JSON.stringify(obj).replaceAll(\",\", \", \");\n    }\n    case \"Write\": {\n      const obj = { command: response.command, bytes: bytes };\n      return JSON.stringify(obj).replaceAll(\",\", \", \");\n    }\n  }\n}\n\nfunction packetBytesToString(packet: Request | Response): string {\n  if (packet.bytes !== undefined) {\n    const array: Array<number> = Array.from(packet.bytes);\n    return array.map((x) => x.toString(16).padStart(2, \"0\")).join(\" \");\n  } else {\n    return \"\";\n  }\n}\n","export type Command = \"Read\" | \"Write\";\n\n// TODO: Add support for error responses\nexport type ResponseCommand = \"Read\" | \"Write\" | \"Error\";\n\nexport enum CommandValue {\n  Read = 0x30,\n  Write = 0x50,\n}\n\nexport const SYNC_MARKER = 0x47;\n\nexport function parse_command(byte: number): Command | null {\n  switch (byte) {\n    case CommandValue.Read:\n      return \"Read\";\n    case CommandValue.Write:\n      return \"Write\";\n    default:\n      return null;\n  }\n}\n\nexport function command_value(command: Command): number {\n  switch (command) {\n    case \"Read\": {\n      return CommandValue.Read;\n    }\n    case \"Write\": {\n      return CommandValue.Write;\n    }\n  }\n}\n\nexport function request_length(command: Command): number {\n  const sync_len = 1;\n  const command_len = 1;\n  const addr_len = 4;\n  const data_len = 4;\n  const crc_len = 1;\n\n  switch (command) {\n    case \"Read\": {\n      return sync_len + command_len + addr_len + crc_len;\n    }\n    case \"Write\": {\n      return sync_len + command_len + addr_len + data_len + crc_len;\n    }\n  }\n}\n\nexport function response_length(command: Command): number {\n  const sync_len = 1;\n  const command_len = 1;\n  const data_len = 4;\n  const crc_len = 1;\n\n  switch (command) {\n    case \"Read\": {\n      return sync_len + command_len + data_len + crc_len;\n    }\n    case \"Write\": {\n      return sync_len + command_len + crc_len;\n    }\n  }\n}\n","const CRC_INIT = 0x47;\nconst CRC_POLY = 0x8d;\nconst CRC_SIZE = 8;\nconst CRC_MASK = 0xff;\n\nexport function crc(bytes: Uint8Array): number {\n  let state = CRC_INIT;\n\n  for (const byte of bytes.values()) {\n    for (let i = CRC_SIZE - 1; i >= 0; i--) {\n      const input = (byte >> i) & 1;\n      const msb = state >> (CRC_SIZE - 1);\n      const feedback = msb ^ input;\n\n      state = (state << 1) & CRC_MASK;\n\n      if (feedback) {\n        state ^= CRC_POLY;\n      }\n    }\n  }\n\n  return state;\n}\n","import { command_value, request_length, SYNC_MARKER } from \"./fields.ts\";\nimport { Request } from \"./packets.ts\";\nimport { crc } from \"./crc.ts\";\n\nexport class RequestEncoder {\n  encode(request: Request): Uint8Array {\n    const length = request_length(request.command);\n    const bytes = new Uint8Array(length);\n    let byte_idx = 0;\n    bytes[byte_idx++] = SYNC_MARKER;\n    bytes[byte_idx++] = command_value(request.command);\n    const buffer = new Uint32Array([request.addr]).buffer;\n    const view = new DataView(buffer);\n    for (let i = 0; i < 4; i++) {\n      bytes[byte_idx++] = view.getUint8(3 - i);\n    }\n    if (request.command === \"Write\") {\n      const buffer = new Uint32Array([request.data]).buffer;\n      const view = new DataView(buffer);\n      for (let i = 0; i < 4; i++) {\n        bytes[byte_idx++] = view.getUint8(3 - i);\n      }\n    }\n    bytes[byte_idx++] = crc(bytes.slice(0, length - 1));\n\n    return bytes;\n  }\n}\n","import {\n  parse_command,\n  response_length,\n  Command,\n  SYNC_MARKER,\n} from \"./fields.ts\";\nimport { Response } from \"./packets.ts\";\nimport { ParseResult } from \"./parse_types.ts\";\n\nexport class ResponseDecoder {\n  bytes: number[];\n\n  constructor() {\n    this.bytes = [];\n  }\n\n  transform(chunk: Uint8Array, controller: TransformStreamDefaultController) {\n    this.accumulate_bytes(chunk);\n    const [next_bytes, result] = this.parse_responses(this.bytes);\n    if (Array.isArray(result)) {\n      const responses = result;\n      for (const response of responses) {\n        controller.enqueue(response);\n      }\n    }\n    this.bytes = next_bytes;\n  }\n\n  accumulate_bytes(chunk: Uint8Array) {\n    for (const byte of chunk) {\n      this.bytes.push(byte);\n    }\n  }\n\n  parse_responses(bytes: number[]): ParseResult<Response[]> {\n    const responses = [];\n    let next = false;\n\n    do {\n      next = false;\n      const [next_bytes, result] = this.parse_response(bytes);\n      if (typeof result === \"object\") {\n        const response = result;\n        responses.push(response);\n        next = true;\n      }\n      bytes = next_bytes;\n    } while (next);\n\n    return [bytes, responses];\n  }\n\n  parse_response(bytes: number[]): ParseResult<Response> {\n    const sop_index = bytes.indexOf(SYNC_MARKER);\n\n    if (sop_index >= 0) {\n      const command_index = sop_index + 1;\n      if (bytes.length > command_index) {\n        const command_byte = bytes[command_index];\n        const command = parse_command(command_byte);\n\n        if (command) {\n          const length = response_length(command);\n          if (bytes.length >= sop_index + length) {\n            const eop_index = sop_index + length;\n            const response_bytes = bytes.slice(sop_index, eop_index);\n            const response = this.parse_response_bounded(\n              command,\n              response_bytes,\n            );\n            return [bytes.slice(eop_index), response];\n          } else {\n            // Not enough bytes for a response\n            return [bytes, \"Incomplete\"];\n          }\n        } else {\n          // Skip bad command\n          return [bytes.slice(command_index + 1), \"Bad\"];\n        }\n      } else {\n        // Not enough bytes for a command byte let alone a full response\n        return [bytes, \"Incomplete\"];\n      }\n    } else {\n      return [bytes, \"None\"];\n    }\n  }\n\n  parse_response_bounded(command: Command, bytes: number[]): Response {\n    switch (command) {\n      case \"Read\": {\n        const buffer = new Uint8Array(bytes).buffer;\n        const view = new DataView(buffer);\n        const data = view.getUint32(2, false);\n        return {\n          command: command,\n          data: data,\n          crc: bytes[6],\n          bytes: new Uint8Array(bytes),\n        };\n      }\n      case \"Write\": {\n        return {\n          command: command,\n          crc: bytes[2],\n          bytes: new Uint8Array(bytes),\n        };\n      }\n    }\n  }\n}\n","import {\n  requestToString,\n  responseToString,\n  Request,\n  Response,\n} from \"./packets.ts\";\nimport { RequestEncoder } from \"./request_encoder.ts\";\nimport { ResponseDecoder } from \"./response_decoder.ts\";\nimport { Adapter, AdapterConstructor, AdapterConstructorParams, AccessCallback, LogCallback } from \"regvue-adapter\";\n\ninterface Connection {\n  port: SerialPort;\n  reader: any;\n  readerClosed: Promise<any>;\n  writer: any;\n  decoder: TransformStream<Uint8Array, Response>;\n}\n\nexport const Client: AdapterConstructor = class Client implements Adapter {\n  name = \"Register Explorer UART\";\n  description = \"Client for the Register Explorer UART protocol\";\n\n  connection: Connection | null;\n  encoder: RequestEncoder;\n  logCallback?: LogCallback;\n  accessCallback?: AccessCallback;\n\n  constructor({accessCallback, logCallback}: AdapterConstructorParams) {\n    this.connection = null;\n    this.logCallback = logCallback;\n    this.accessCallback = accessCallback;\n    this.encoder = new RequestEncoder();\n  }\n\n  async connect() {\n    const port = await navigator.serial.requestPort();\n    await port.open({\n      baudRate: 115200,\n      parity: \"odd\",\n    });\n\n    if (!port.readable || !port.writable) {\n      return;\n    }\n\n    const decoder = new TransformStream(new ResponseDecoder());\n    const readerClosed = port.readable.pipeTo(decoder.writable);\n    const reader = decoder.readable.getReader();\n    const writer = port.writable.getWriter();\n\n    this.connection = {\n      port: port,\n      reader: reader,\n      readerClosed: readerClosed,\n      writer: writer,\n      decoder: decoder,\n    };\n\n    this.log(\"Connected\");\n  }\n\n  async disconnect() {\n    if (this.connection) {\n      this.connection.writer.releaseLock();\n      await this.connection.reader.cancel().catch(() => {\n        // Ignore error\n      });\n      await this.connection.readerClosed.catch(() => {\n        // Ignore error\n      });\n      await this.connection.port.close();\n      this.connection = null;\n      this.log(\"Disconnected\");\n    }\n  }\n\n  async write(addr: number, data: number) {\n    await this.writeRequest({\n      command: \"Write\",\n      addr: addr,\n      data: data,\n      crc: 0,\n    });\n\n    try {\n      const response = await this.readResponse();\n      if (response.command == \"Write\") {\n        if (this.accessCallback) {\n          this.accessCallback({\n            type: \"Write\",\n            addr: addr,\n            data: data\n          });\n        }\n      } else {\n        throw \"invalid\";\n      }\n    } catch {\n      // Ignore\n    }\n  }\n\n  async read(addr: number): Promise<number> {\n    await this.writeRequest({\n      command: \"Read\",\n      addr: addr,\n      crc: 0,\n    });\n    try {\n      const response = await this.readResponse();\n      if (response.command === \"Read\") {\n        if (this.accessCallback) {\n          this.accessCallback({\n            type: \"Read\",\n            addr: addr,\n            data: response.data\n          });\n        }\n        return response.data;\n      } else {\n        throw \"invalid\";\n      }\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async writeRequest(request: Request) {\n    request.bytes = this.encoder.encode(request);\n    this.log(\"Request \" + requestToString(request));\n\n    if (this.connection) {\n      this.connection.writer.write(request.bytes);\n    }\n  }\n\n  async readResponse(): Promise<Response> {\n    try {\n      const response = await Promise.race<Response>([\n        this.readResponseWithoutTimeout(),\n        this.responseTimeout(1000),\n      ]);\n      return response;\n    } catch (e) {\n      if (this.connection) {\n        await this.connection.reader.cancel().catch(() => {\n          // Ignore error\n        });\n      }\n      this.log((e as Error).message);\n      throw e;\n    }\n  }\n\n  async responseTimeout(ms: number): Promise<never> {\n    return new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(\"Timeout waiting for response\")), ms);\n    });\n  }\n\n  async readResponseWithoutTimeout(): Promise<Response> {\n    if (!this.connection) {\n      throw new Error(\"Attempt to read a response without a connection\");\n    }\n\n    const { value, done } = await this.connection.reader.read();\n    if (done) {\n      this.connection.reader.releaseLock();\n      throw new Error(\"No response\");\n    }\n\n    const response = value;\n    this.log(\"Response \" + responseToString(response));\n    return response;\n  }\n\n  log(message: string) {\n    if (this.logCallback) {\n      this.logCallback(message);\n    } else {\n      console.log(message);\n    }\n  }\n}\n","import {\n  parse_command,\n  request_length,\n  Command,\n  SYNC_MARKER,\n} from \"./fields.ts\";\nimport { Request } from \"./packets.ts\";\nimport { ParseResult } from \"./parse_types.ts\";\n\nexport class RequestDecoder {\n  bytes: number[];\n\n  constructor() {\n    this.bytes = [];\n  }\n\n  transform(chunk: Uint8Array, controller: TransformStreamDefaultController) {\n    this.accumulate_bytes(chunk);\n    const [next_bytes, result] = this.parse_requests(this.bytes);\n    if (Array.isArray(result)) {\n      const requests = result;\n      for (const request of requests) {\n        controller.enqueue(request);\n      }\n    }\n    this.bytes = next_bytes;\n  }\n\n  accumulate_bytes(chunk: Uint8Array) {\n    for (const byte of chunk) {\n      this.bytes.push(byte);\n    }\n  }\n\n  parse_requests(bytes: number[]): ParseResult<Request[]> {\n    const requests = [];\n    let next = false;\n\n    do {\n      next = false;\n      const [next_bytes, result] = this.parse_request(bytes);\n      if (typeof result === \"object\") {\n        const request = result;\n        requests.push(request);\n        next = true;\n      }\n      bytes = next_bytes;\n    } while (next);\n\n    return [bytes, requests];\n  }\n\n  parse_request(bytes: number[]): ParseResult<Request> {\n    const sop_index = bytes.indexOf(SYNC_MARKER);\n\n    if (sop_index >= 0) {\n      const command_index = sop_index + 1;\n      if (bytes.length > command_index) {\n        const command_byte = bytes[command_index];\n        const command = parse_command(command_byte);\n\n        if (command) {\n          const length = request_length(command);\n          if (bytes.length >= sop_index + length) {\n            const eop_index = sop_index + length;\n            const request_bytes = bytes.slice(sop_index, eop_index);\n            const request = this.parse_request_bounded(command, request_bytes);\n            return [bytes.slice(eop_index), request];\n          } else {\n            // Not enough bytes for a request\n            return [bytes, \"Incomplete\"];\n          }\n        } else {\n          // Skip bad command\n          return [bytes.slice(command_index + 1), \"Bad\"];\n        }\n      } else {\n        // Not enough bytes for a command byte let alone a full request\n        return [bytes, \"Incomplete\"];\n      }\n    } else {\n      return [bytes, \"None\"];\n    }\n  }\n\n  parse_request_bounded(command: Command, bytes: number[]): Request {\n    const buffer = new Uint8Array(bytes).buffer;\n    const view = new DataView(buffer);\n    const addr = view.getUint32(2, false);\n\n    switch (command) {\n      case \"Read\": {\n        return {\n          command: command,\n          addr: addr,\n          crc: bytes[6],\n          bytes: new Uint8Array(bytes),\n        };\n      }\n      case \"Write\": {\n        const data = view.getUint32(6, false);\n        return {\n          command: command,\n          addr: addr,\n          data: data,\n          crc: bytes[10],\n          bytes: new Uint8Array(bytes),\n        };\n      }\n    }\n  }\n}\n","import { command_value, response_length, SYNC_MARKER } from \"./fields.ts\";\nimport { Response } from \"./packets.ts\";\nimport { crc } from \"./crc.ts\";\n\nexport class ResponseEncoder {\n  encode(response: Response): Uint8Array {\n    const length = response_length(response.command);\n    const bytes = new Uint8Array(length);\n    let byte_idx = 0;\n    bytes[byte_idx++] = SYNC_MARKER;\n    bytes[byte_idx++] = command_value(response.command);\n    if (response.command === \"Read\") {\n      const buffer = new Uint32Array([response.data]).buffer;\n      const view = new DataView(buffer);\n      for (let i = 0; i < 4; i++) {\n        bytes[byte_idx++] = view.getUint8(3 - i);\n      }\n    }\n    bytes[byte_idx++] = crc(bytes.slice(0, length - 1));\n\n    return bytes;\n  }\n}\n","import {\n  requestToString,\n  responseToString,\n  Request,\n  Response,\n} from \"./packets\";\nimport { RequestDecoder } from \"./request_decoder\";\nimport { ResponseEncoder } from \"./response_encoder\";\n\ninterface Connection {\n  port: SerialPort;\n  reader: any;\n  readerClosed: Promise<any>;\n  writer: any;\n  decoder: TransformStream<Uint8Array, Request>;\n}\n\ntype Logger = (message: string) => void;\n\nexport class ServerModel {\n  connection: Connection | null;\n  encoder: ResponseEncoder;\n  logger?: Logger;\n  updateMemCallback?: Logger;\n  mem: Map<number, number>;\n\n  constructor(logger?: Logger, updateMemCallback?: Logger) {\n    this.connection = null;\n    this.logger = logger;\n    this.updateMemCallback = updateMemCallback;\n    this.encoder = new ResponseEncoder();\n    this.mem = new Map();\n  }\n\n  async connect() {\n    const port = await navigator.serial.requestPort();\n    await port.open({\n      baudRate: 115200,\n      parity: \"odd\",\n    });\n\n    if (!port.readable || !port.writable) {\n      return;\n    }\n\n    const decoder = new TransformStream(new RequestDecoder());\n    const readerClosed = port.readable.pipeTo(decoder.writable);\n    const reader = decoder.readable.getReader();\n    const writer = port.writable.getWriter();\n\n    this.connection = {\n      port: port,\n      reader: reader,\n      readerClosed: readerClosed,\n      writer: writer,\n      decoder: decoder,\n    };\n\n    this.log(\"Connected\");\n  }\n\n  async listen() {\n    if (!this.connection) {\n      return;\n    }\n\n    while (this.connection.port.readable) {\n      const result = await this.connection.reader.read();\n      if (result.done) {\n        return;\n      }\n      const request = result.value;\n      this.log(requestToString(request));\n\n      switch (request.command) {\n        case \"Write\":\n          this.mem.set(request.addr, request.data);\n          this.updateMemString(this.mem);\n          await this.send_response(this.encoder, this.connection.writer, {\n            command: \"Write\",\n            crc: 0,\n          });\n\n          break;\n        case \"Read\":\n          const data = this.getMemEntry(request.addr);\n          await this.send_response(this.encoder, this.connection.writer, {\n            command: \"Read\",\n            data: data,\n            crc: 0,\n          });\n          break;\n      }\n    }\n  }\n\n  async disconnect() {\n    if (this.connection) {\n      this.connection.writer.releaseLock();\n      await this.connection.reader.cancel().catch(() => {\n        // Ignore error\n      });\n      await this.connection.readerClosed.catch(() => {\n        // Ignore error\n      });\n      await this.connection.port.close();\n      this.connection = null;\n      this.log(\"Disconnected\");\n    }\n  }\n\n  async send_response(\n    encoder: ResponseEncoder,\n    writer: WritableStreamDefaultWriter<Uint8Array>,\n    response: Response,\n  ) {\n    response.bytes = encoder.encode(response);\n    this.log(responseToString(response));\n    await writer.write(response.bytes);\n  }\n\n  log(message: string) {\n    if (this.logger) {\n      this.logger(message);\n    }\n  }\n\n  getMemEntry(addr: number): number {\n    if (!this.mem.has(addr)) {\n      return Math.floor(Math.random() * 0xffffffff);\n    } else {\n      return this.mem.get(addr) || 0;\n    }\n  }\n\n  updateMemString(mem: Map<number, number>) {\n    if (!this.updateMemCallback) {\n      return;\n    }\n    const value = Array.from(mem.entries())\n      .map(([a, b]) => {\n        return (\n          a.toString(16).padStart(8, \"0\") +\n          \":\" +\n          b.toString(16).padStart(8, \"0\")\n        );\n      })\n      .join(\"\\n\");\n    this.updateMemCallback(value);\n  }\n}\n"],"names":["requestToString","request","bytes","packetBytesToString","addr","obj","data","responseToString","response","packet","x","SYNC_MARKER","parse_command","byte","command_value","command","request_length","response_length","CRC_INIT","CRC_POLY","CRC_SIZE","CRC_MASK","crc","state","i","input","feedback","RequestEncoder","length","byte_idx","buffer","view","ResponseDecoder","__publicField","chunk","controller","next_bytes","result","responses","next","sop_index","command_index","command_byte","eop_index","response_bytes","Client","accessCallback","logCallback","port","decoder","readerClosed","reader","writer","e","ms","_","reject","value","done","message","RequestDecoder","requests","request_bytes","ResponseEncoder","ServerModel","logger","updateMemCallback","encoder","mem","a","b"],"mappings":"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"}